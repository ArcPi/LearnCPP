## 3.1 命名空间的using声明
既可以使用using 声明命名空间也可以使用using声明每个要用到的名字
#### 头文件不应包含using声明
如果头文件有某个using声明，引用该头文件的所有文件都可以使用该using声明，这有可能发生冲突，显然不是我们所希望看到的
## 3.2 标准库类型string
### 3.2.1 定义和初始化string对象
#### 直接初始化和拷贝初始化区别
ClassTest ct2 = "ab";
它本来是要这样来构造对象的：首先调用构造函数ClassTest(const char *pc)函数创建一个临时对象，然后调用复制构造函数，把这个临时对象作为参数，构造对象ct2。然而编译也发现，复制构造函数是公有的，即你明确地告诉了编译器，你允许对象之间的复制，而且此时它发现可以通过直接调用重载的构造函数ClassTest(const char *pc)来直接初始化对象，而达到相同的效果，所以就把这条语句优化为ClassTest ct2（"ab"）。
### 3.2.2 string对象上的操作
```c++
#include <iostream>
#include <string>

using namespace std;

int main() {
   string line;
   while(getline(cin, line))
   {
       cout<<line<<endl;
   }

}
```
触发getline函数返回的那个换行符实际上被丢掉了，得到的string对象并不包含该换行符。
#### string::size_type类型
string中size()函数返回的是size_type类型。这种类型实现了与机器无关的特性，并且能够转化为int、unsigned int。
#### 为string对象赋值
#### 两个string对象相加
#### 字面值和string对象相加
### 3.2.3 处理string对象中的字符
头文件 cctype
建议使用C++版本的C标准库头文件
用法：
去掉.h在前边加上c
#### 处理每个字符，使用基于范围的for语句
不需要改变字符，使用
```c++
for(auto c : expression)
```
需要改变字符，使用
```c++
for(auto &c : expression)
```
#### 注意：
使用下标访问string，确保其在安全的范围内，C++标准并不要求标准库检测下标是否合法。

## 3.3 标准库类型vector
vector表示对象的集合，其中所有的对象的类型都相同，并建立唯一与之对应的索引。vector“容纳着”其他对象，也通常被称作容器。vector是类模板。
模板本身不是类或函数，可以将模板看作为编译器生成类或函数编写的一份说明书。编译器根据模板创建类或者函数的过程称为实例化。使用模板时，需要指定类型。
引用不是对象，不能被vector容纳。
同理，vector下标的类型是相应的size_type类型
注意，vector只能对明确已知存在的元素执行下标操作。
## 3.4 迭代器
#### 迭代器类型
iterator：能读能写
const_iterator:只能读取，不能写
->箭头运算符：将解引用和成员访问两个操作结合在一起
#### 某些对vector对象的操作会使迭代器失效
不能在范围for循环中向vector对象添加元素。
任何一种可能改变vector对象容量的操作，都会使该vector对象的迭代器失效。
## 3.5 数组
#### 字符数组的特殊性
注意直接赋值字符和直接字符串赋值的区别。
#### 不允许拷贝和赋值
#### 理解复杂的数组声明
不存在引用的数组
### 3.5.2 访问数组元素
使用数组下标的时候，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型。
#### 检查下标的值
内置数组不负责检查下标的值