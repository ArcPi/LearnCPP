## 10.1 概述
大多数算法都定义在头文件algorithm中。标准库还在头文件numeric中定义了一组数值泛型算法。
***关键概念***
泛型算法本身不会执行容器的操作，它只会运行于迭代器之上，执行迭代器的操作。
## 10.2 初识泛型算法
### 10.2.1 只读算法
accumulate()求和算法，由于string中重载了"+"，所以也可以使用accumulate
### 10.2.2 写容器元素的算法
当我们使用这类算法时，必须注意确保序列原大小至少不小于我们要求算法写入的元素的数目。***算法不会执行容器操作，因此他们本身不能改变容器的大小***
#### 算法不检查写操作
#### back_inserter
插入迭代器
#### 拷贝算法
### 10.2.3 重排容器元素的算法
## 10.3 定制操作
### 10.3.1 向算法传递函数
#### 谓词 
谓词是一个可调用的表达式，其返回结果是一个能用做条件的值。
一元谓词：只接受一个参数
二元谓词：接受两个参数
#### 排序算法
### 10.3.2 lambda
lambda表达式的形式：
```
[capture list] (parameter list) -> return type {function body}
```
#### 向lambda传递参数
#### 使用捕获列表
一个lambda只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。
#### 调用find_if
#### for_each算法
### 10.3.3 lambda捕获和返回
当定义一个lambda时，编译器生成一个与lambda对应的新的(未命名)类类型。
#### 值捕获
类似参数传递，变量的捕获方式可以是值或引用。
我们应该尽量减少捕获的数据量，来避免潜在的 捕获导致的问题。而且，有过有可能的话，应该避免捕获指针或引用。
#### 隐示捕获
&告诉编译器采用捕获引用方式，=告诉采用值捕获方式。
#### 指定lambda返回类型
### 10.3.4 参数绑定
## 10.4 再探迭代器
迭代器有一下几种：
插入迭代器
流迭代器
反向迭代器
移动迭代器
### 10.4.1 插入迭代器
插入迭代器是一种迭代适配器，他接受一个容器，生成一个迭代器，能实现向给定容器添加元素。
插入器有三种类型，差异在于元素插入的位置：
back_inserter:创建一个使用push_back的迭代器
front_inserter创建一个使用push_front的迭代器
inserter：创建一个指定位置插入的迭代器
### 10.4.2 iostream迭代器
虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器。
#### istream_iterator操作
当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个istream_iterator使用>>来读取流。因此。istream_iterator要读取的类型必须定义了输入运算符。当创建一个istram_iterator时，我们可以将它绑定到一个流。
#### istream_iterator允许使用懒惰求值
### 10.4.3 反向迭代器
## 泛型算法结构
|  迭代器 |  用法 |
|---|---|
| 输入迭代器  |  只读，不写；单遍扫描，只能递增 |
| 输出迭代器  | 只写，不读；单遍扫描，只能递增  |
|  前向迭代器 | 可读写；多遍扫描，只能递增  |
| 双向迭代器  |  可读写，多遍扫描,可递增递减 |
|随机访问迭代器|可读写，多遍扫描，支持全部迭代器运算|
### 10.5.1 5类迭代器
类似容器，迭代器也定义了一组公共操作。一些操作所有迭代器都支持。
例如，ostream_iterator只支持递增、解引用和赋值。
vector、string、deque的迭代器除了这些操作，还支持递减、关系和算数运算。
### 10.5.2 算法形参模式
### 10.5.3 算法命名规范
#### 一些算法使用重载形式传递一个谓词
#### _if版本的算法
#### 区分拷贝元素的版本和不拷贝元素的版本
## 10.6 特定容器算法
