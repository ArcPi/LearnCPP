当定义一个类时，我们显式的或隐示的指定在此类型的对象那个的拷贝、移动、赋值和销毁时做什么。
一个类通过定义五中特殊的成员函数来控制这些操作：
拷贝构造函数
拷贝赋值运算符
移动构造函数
移动赋值运算符
析构函数
拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。
拷贝和移动赋值运算符定义了讲一个对象赋予同类型的另一个对象时做什么。
析构函数定义了当此类型对象销毁时做什么。
我们称这些操作为拷贝控制操作。
## 13.1 拷贝、赋值与销毁
### 13.1.1 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且额外参数有默认值，则此构造函数是拷贝构造函数。
例如
```
class Foo{
public：
        Foo(); // 默认构造函数
        Foo(const Foo&);  // 拷贝构造函数
}
```
拷贝构造函数的第一个参数必须是一个引用类型，而且最好是const引用。
#### 合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，及时我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。
对于某些类来说，合成构造函数用来组织我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中一次将每个非static成员拷贝到正在创建的对象中。
每个成员的类型决定了它如何拷贝：对类类型成员，会使用器拷贝函数来拷贝；内置类型的成员则直接拷贝。
#### 拷贝初始化
```
string dots(10, '.'); // 直接初始化
string s(dots); // 直接初始化
string s2 = dots； // 拷贝初始化
string null_books = "99-9999999-99"； // 拷贝初始化
string nines = string(100, '9');  // 拷贝初始化
```
当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。
当使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝带正在创建的对象中，如果有需要的话，还要进行类型转换。
拷贝舒适化通常使用拷贝构造函数来完成。如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。
拷贝初始化不仅在用=定义变量时会发生，在下列情况也会发生：
1. 将一个对象作为实参传递给一个非引用类型的形参。
2. 从一个返回类型为非引用类型的函数返回一个对象
3. 用花括号列表初始化一个数组中的元素或这一个聚合类中的成员

某些类类型还会对他们所分配的对象那个使用拷贝初始化。例如，我们初始化标准库容器或者是调用其insert或者push成员，容器会对其元素进行拷贝初始化。与之相对的，用emplace成员创建的元素都进行直接初始化。
#### 参数和返回值
在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似地，当一个函数具有非引用的返回类型是，返回值会被用来初始化调用方的结果。
拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远不会成功。
#### 拷贝初始化的限制
#### 编译器可以绕过拷贝构造函数
### 13.1.2 拷贝赋值运算符
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为他合成一个。
#### 重载赋值运算符
重载运算符本质上是函数，operator关键字后接表示要定义的运算符的符号组成。例如operator=。
赋值运算符通常应该返回一个指向其左侧运算对象的引用。
#### 合成拷贝运算符
如果没有定义，编译器会为他生成一个合成拷贝赋值运算符。
对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。
合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。
### 13.1.3 析构函数
析构函数释放对象使用的资源，并销毁对象的非static数据成员。
析构函数是类的一个成员函数，名字由波浪号接类名构成。没有返回值，也不接受参数。
#### 析构函数完成什么工作
#### 什么时候会调用析构函数
无论何时一个对象被销毁，就会自动调用其析构函数：
1. 变量离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器（无论标准库容器还是数组）被销毁时，其元素被销毁
4. 对于动态分配的对象，当指向它的指针被销毁时
5. 对于临时对象，当穿件它的完整表达式结束时被销毁
#### 合成析构函数
对于某些类，合成析构函数被用来阻止该类型的对象被销毁。
### 13.1.4 三/五法则
三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。
新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。
#### 需要析构函数的类也需要拷贝和赋值操作
如果一个类需要一个析构函数，我们几乎肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。
#### 需要拷贝操作的类也需要赋值操作，反之亦然
### 13.1.5 使用=default
我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本
当我们在类内用=default修饰成员的声明时，合成的函数将隐示的声明为内联的。
我们只能对具有合成版本的成员函数使用=default
### 13.1.6 阻止拷贝
对于某些类来说，拷贝构造函数和拷贝赋值运算符，这些操作没有意义，在此情况下，定义类时必须采用某种机制阻止拷贝或者赋值。例如，iostream类阻止了拷贝。
#### 定义删除的函数
我们可以将拷贝构造函数和拷贝赋值运算函数定义为删除的函数来阻止拷贝。
删除函数：我们虽然声明了它，但不能以任何方式使用他们
在函数参数列表后边加上=delete来指出我们希望将他定义为删除的
与=default不同，=delete必须出现在函数第一次声明的时候。
#### 析构函数不能是删除的成员
#### 合成的拷贝控制成员可能是删除的
对于某些类来说，编译器会将这些合成的成员定义为删除的函数：
1. 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
2. 如果类的某个成员的拷贝搞糟函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。
3. 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝运算符被定义为删除的。
4. 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用城公园，它没有类内初始化其，或是类有一个const成员，它没有类内初始化其且其类型未显示定义默认构造函数，则该类的默认构造函数被定因为删除的。
综上，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。
#### private拷贝控制
## 13.2 拷贝控制和资源管理
