# 一 传递临时对象作为线程参数
## 要避免的陷阱
1. 用detach()时，传引用可以（传引用在thread中也是传递的值，这个是thread自己优化的吧），传指针不可以(不推荐用引用，绝对不能用指针)
2. 用detach()时，thread中传指针的时候用临时对象转一下就行。
   
**总结**
在使用detach时，thread需要注意一些地方，普通内置类型直接就可以传递，自己构造的对象类型需要用临时对象转一下再传递就没有问题，函数入口的对象参数最好是引用类型（节省一次构造）。使用join时，就没有这么多的坑坑。

**再总结**
使用thread的时候，传递的参数直接传线程入口函数所需要的类型，这样所有的构造函数就会由主线程给你构造出来，如果不是这样，可能就会使用子线程构造对象，这样如果主线程退出了，主线程的局部变量就失效了。

使用子线程构造对象的情况
```c++

void myfunc(const A& objA){}

A{};

int main()
{
    thread mythread(myfunc, 1); //这种情况就会发生子线程调用构造函数的情况
    thread mythread2(myfunc, A(1)); //与函数入口参数相同，使用主线程调用构造函数
}

```

# 二 临时对象作为线程参数深入

1. 线程id的概念，每个线程都对应着一个数字，使用std::this_thread::get_id()获取线程id

**使用thread的传递线程参数时候的表现**
2. 不使用临时对象转一下，类型转换构造函数，以及后续的构造函数是在子线程中构造出来的
3. 使用临时对象转一下，所有的构造函数都是在主线程中构造出来的


# 三 传递类对象 智能指针作为线程参数
1. 即使我们的入口函数写的是myfunc(const obj&),使用thread传递过去的仍是另外构造的一个对象，非要在其他线程中引用或者修改这个线程的变量，我们必须使用std::ref
```c++
void myfunc(const obj&){};

int main()
{
    std::thread mythreadobj(myfunc, std::ref(myobj));
}
```
2. 传递智能指针
