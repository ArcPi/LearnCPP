# 一 线程运行的开始和结束
1. 主线程从main()函数开始执行
2. 自建的线程，需要村一个函数开始运行（初始函数）
3. 主线程执行完了，其他子线程没有执行完，那么子线程也会被强制终止
4. 所以，如果大家想保持子线程的运行状态的话，那么大家要让主线程一直运行。
5. thread: 标准库里边的类
这个程序有两条线在走，即使一条线被堵住了，另一条线也是可以通行的。
```c++
void myprint()
{
	cout << "Hello world" << endl;
}

int main()
{
	thread mytobj(myprint); // 接受一个可调用对象， 线程执行的入口，线程开始执行
	mytobj.join(); // 主线程阻塞，等待子线程执行完。
	cout << "I love china!" << endl; // 主线程从main()函数开始执行
}

```
6. join(): 加入汇合，说白了就是阻塞主线程，让主线程等待子线程执行完毕，然后子线程和主线程汇合，然后再往下走.
7. detach(): 分离，也就是主线程不和子线程汇合了，各自执行各自的，分离执行。一旦detach之后，与主线程关联的对象，就会失去关联，此时这个子线程就会驻留再后台运行。这个子线程就被C++运行时库接管，当子线程执行完成后，由运行时库负责清理该线程相关的资源（守护线程）
8. joinable():判断是否可以成功使用join()或者detach(),可以返回为true，否则返回false。
# 二 其他创建线程的手法
1. 用类对象（可调用对象）。线程中对象要复制进去最好。
2. lambda表达式创建线程。
# 三 总结
1. 如果传递int这种简单类型参数，建议都是值传递，不要用引用，防止节外生枝。
2. 如果传递类对象，避免隐式类型转换。全部都在创建线程这一行构建出临时对象来，然后在函数参数里，用引用来接。不用引用来接，会调用三次拷贝构造函数。用引用来接，只构造两次拷贝构造函数

# 四 线程ID
1. 不同的线程，线程ID不同
2. std::this_thread::get_id()来获取线程ID
 
 # 五 传递类对象，智能指针作为参数
 如果真的非得要传递引用给子线程，要加std::ref()