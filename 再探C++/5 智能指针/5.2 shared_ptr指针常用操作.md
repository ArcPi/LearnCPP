#### 一 shared_ptr引用计数的增加和减少
1. 共享式，只有最后一个指向该对象的shared_ptr指针被销毁时，内存块才会被销毁
2. 引用计数增加的情况
    a. 初始化，计数增加
    b. 做函数实参，计数增加
    c. 做函数返回值，计数增加
   **如果智能指针做函数参数参数是引用，这样指针计数不会增加。**
3. 计数减少的情况
   a. 智能指针指向新的对象
   b. 局部的智能指针离开作用域
```c++
auto p1 = make_shared<int>(100);
auto p2(p1);
```
用一个智能指针初始化另一个智能指针；
把智能指针当作实参往参数里传递；
1. 引用计数减少的情况
智能指针指向新对象或者智能指针被销毁时（离开其作用域时）

#### 三 use_count（）
查看有多少个智能指针
#### 四 unique（）
是否该智能指针独占该对象，也就是若只有一个智能指针指向某个对象，则unique()返回为true
#### 五 reset() (表达的就是reset的本意 )
1. 不带参数时，p若是唯一指向该对象的指针，释放p所指向的对象，并将p置空
2. 不带参数时，若不是唯一指向该内存的指针，引用计数减1，同时将p置空
3. 带参数时，p若是唯一指向该对象的指针，p指向新对象，并将原来的内容清空
4. 带参数时，p不是唯一指向该对象的指针，原来引用计数减1，执行那个新对象

#### 六 get()
1. 返回该智能指针指向的裸指针
2. 主要是有些库需要裸指针

#### 七 swap()
1. 交换两个智能指针所指向的对象（只能是同种类型的）

#### 八 指定删除器额外说明
1. 就算是两个shared_ptr指定了不同的删除器，只要他们所指向的对象类型相同，那么这两个shared_ptr也属于同意一个类型
2. shared_ptr管理动态数组，需要我们自己指定删除器

#### make_shared是提倡的生成shared_ptr的方法，这样不能指定自己的删除器了。