## 15.3 虚函数
#### 对虚函数的调用可能在运行时才被运行
当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行是才能确定应该调用哪个版本的函数
#### 派生类中的虚函数
当我们在派生类中覆盖了某个虚函数时，可以再一次使用virtual关键字支出该函数的性质。
#### final和override说明符
显示的加override可以让编译器检查我们重载是否写对了。
如果将函数定义为了final，之后的任何操作都会引发错误。
#### 回避虚函数的机制
在某些情况下，我们希望强迫虚函数执行某个版本。使用作用域运算符可以实现这一目的。
```c++
double undiscounted = baseP->Quote::net_price(42);
```
通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。
## 15.4 抽象基类
#### 纯虚函数
用法
```c++
double net_price()const =0 ;
```
#### 含有纯虚函数的类是抽象基类
我们不能构建抽象基类的对象
#### 派生类构造函数只初始化他的直接基类
## 15.5 访问控制与继承
#### 受保护的成员
protected：
1. 和私有成员类似，受保护的成员对于类的用户来说是不可访问的
2. 和公有成员类似，受保护的成员对于派生类的成员和友元来说是可访问的
3. 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。
#### 公有、私有和受保护继承
#### 友元与继承
就像友元关系不能传递一样，友元关系同样不能继承。
不能继承友元关系：每个类负责控制各自成员的访问权限。
#### 改变个别成员的可访问性
使用using声明。
派生类只能为那些它可以访问的名字提供using声明。
#### 默认的继承保护级别
struct默认是公有继承
class默认是私有继承
## 15.6 继承中的类作用域
## 15.7 构造函数与拷贝控制
### 15.7.1 虚析构函数
如果基类的析构函数不是虚函数，则delete一个指向派生类对象的基类指针将产生未定义的行为。
经验准则：如果一个类需要析构函数，那么它也同样需要拷贝和赋值运算。基类的析构函数并不遵循上述准则，他是一个重要的例外。一个基类总是需要析构函数，而且它能将析构函数设为虚函数。此时该析构函数为了成为虚函数儿另内容为空，我们显然无法由此腿短该积累还需要赋值运算符或拷贝构造函数。
#### 虚析构函数将组织合成移动操作
基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。
#### 派生类中删除的拷贝控制与基类的关系
就像其他任何类的情况一样，基类或派生类也能出于同样的原因将其合成的默认构造函数或者任何一个拷贝控制成员定义成被删除的函数。此外，某些定义基类的方式也可能导致有的派生类成员成为被删除的函数：
1. 如果基类中的默认鼓噪函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的。原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。
2. 如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分。
3. 编译器将不会合成一个删除掉的移动操作。当我们使用=default请求一个移动操作时，如果基类中的对应的操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象基类部分不可移动。同样如果基类的析构函数是阐述的或者不可访问的，则派生类的移动构造函数也是被删除的。
#### 移动操作与继承
在默认情况下，基类通常不含有合成的移动操作，而且在他的派生类中也没有合成的移动操作。
因为基类缺少移动操作会阻止派生类拥有自己的移动合成操作，所以当我们确实需要移动擦做时应该首先在基类中定义。
### 15.7.3 派生类的拷贝控制成员
派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还要负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同事，也要拷贝和移动基类部分的成员。
和构造函数及赋值运算符不同的是，析构函数只负责销毁派生类自己分配的资源。
#### 定义派生类的拷贝或移动构造函数
在默认情况下，基类默认构造函数初始化派生类对象的基类部分。如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始列表中显示的使用基类的拷贝（或移动）构造函数。
#### 派生类赋值运算符
与拷贝和移动构造函数一样，派生类的赋值运算符也必须显式地为其基类部分赋值。
#### 派生类析构函数
派生类析构函数只负责销毁由派生类自己分配的资源
#### 在构造函数和析构函数中调用虚函数
如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。
### 15.7.4 继承的构造函数
#### 继承的构造函数的特点
一个构造函数的using声明不会改变构造函数的访问级别。不管using声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数。
using声明语句不能制定explicit或constexpr。只会统统继承自基类。
## 15.8 容器与继承
当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。
#### 在容器中放置（智能）指针而非对象
