动态分配的对象的生存周期与它们在哪里创建是无关的，只有显示的释放时，这些对象才会销毁。
静态内存：保存局部static对象、类static数据成员以及定义在任何函数之外的变量。
栈内存：保存在函数内的非static对象。
堆：程序用堆来存储动态分配的对象，即，那些程序在运行时分配的对象。
## 12.1 动态内存与智能指针
动态内存的管理是通过一对运算符完成的：
new：在动态内存中为对象分配空间并返回一个指向该对象的指针。
delete：接受一个动态指针的对象，销毁该对象，并释放与之关联的内存。
shared_ptr:允许多个指针指向同一个对象。
unique_ptr:独占的指向对象。
weak_ptr：弱引用，指向shared_ptr所管理的对象。
### 12.1.1 shared_ptr类
类似vector，智能指针也是模版。
#### make_shared函数
#### shared_ptr自动销毁所管理的对象
当指向一个对象的最后一个shared_ptr被销毁是，shared_ptr类会自动销毁此对象。
#### 使用了动态生存期的资源的类：
程序使用动态内存出于一下三种原因之一：
1. 程序不知道自己需要使用多少对象
2. 程序不知道所需对象的准确类型
3. 程序需要在多个对象间共享数据

### 12.1.2 直接管理内存
### 12.1.3 shared_ptr和new结合使用
必须使用直接初始化形式来初始化一个智能指针：
```
shared_ptr<int> p2(new int(1024));
```
#### 不要混合使用普通指针和智能指针
### 12.1.4 智能指针和异常
### 12.1.5 unique_ptr
### 12.1.6 weak_ptr
## 12.2 动态数组
### 12.2.1 new和数组
#### 分配一个数组会得到一个元素类型的指针
#### 初始化动态分配对象的数组
#### 动态分配一个空数组是合法的
#### 释放动态数组
delete [] pa;
#### 智能指针和动态数组
### 12.2.2 allocator类
new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。
当分配一大块内存时，我们通常计划在这块内存上按需构造对象。
可以分配大块内存，但只有在真正需要时才真正构造对象。
#### allocator类
类似vector,allocator是一个模版。
```
allocator<string> alloc; // 可以分配给string的allocator对象
auto const p = alloc.alloc.allocate(n)； \\ 分配n个未初始化的string
```
#### allocator分配未构造的内存
allocator分配的内存是未构造的。我们按需要在此内存中构造对象。
```
alloc.construct(p, args);
```
为了使用allocate返回的内存，我们必须用construct构造对象。
使用完后，用下边语句销毁元素。
```
alloc.destroy(q); // 释放我们构造的
```
我们只能对真正构造了的元素进行destroy操作。
元素被销毁后，若要释放内存，通过如下语句。
```
alloc.deallocate(p, n);
```
传递给allocate的指针不能为空，它必须指向有allocate分配的内存。
#### 拷贝和填充未初始化内存的算法
例如下边算法
```
auto p = alloc.allocate(vi.size()*2); // 分配比vi所占用空间大一倍的动态内存
auto p = uninitialized_copy(vi.begin(), vi.end(), p); // 通过拷贝vi中的元素来构造从p开始的元素
uninitialized_fill_n(q, vi.size(), 42); // 将剩余元素初始化为42
```
## 12.3 使用标准库：文本查询程序