## 6.1 函数基础
### 6.1.1 局部对象
自动对象：只存在域块执行期间的对象称为自动对象。
局部静态对象：生命周期贯穿函数调用以及之后的时间。
### 6.1.2 函数声明
在头文件中进行声明的好处：
可以确保同一函数的所有生命保持一致。
### 6.1.3 分离式编译
## 6.2 参数传递
区别传值和传引用的区别。
### 6.2.1 传值参数
使用引用避免拷贝。
如果函数无需改变引用星灿的值，最好将其声明为常量引用。
### 6.2.3 const形参和实参
尽量使用常量引用。
### 6.2.4 数组形参
数组是不允许拷贝的，所以无法传值使用。
有下边三种表达方式：
```c++
void print(const int*)
void print(const int[])
void print(cosnt int[10])//维度表示我们期望数组含有多少元素
```
尽管形式不同，这三个print函数是等价的。
每个函数都有一个const int*类型的形参。
***传递多维数组***
```c++
void print(int (*matrix)[10])
void print(int *matrix[10])
        ||
void print(int matrix[][10])
```
两者间是有区别的，第一个是指向含有十个整数的数组的指针
第二个是十个指针构成的数组.
二三是等价的。
### 6.2.6 含有可变形参的函数
#### initializer_list形参
如果函数的实参数量位置但是全部实参的类型都相同，我们可以使用initializer_list类型的形参。
#### 省略符形参
省略符形参只能出现在形参列表的最后一个位置，有以下两种形式。
```c++
void foo(parm_list, ...)
void foo(...)
```
## 6.3 返回类型和return语句
两种形式：
```c++
return;
return expression;
```
### 6.3.1 无返回值函数
### 6.3.2 有返回值函数
***不要返回局部对象的引用或指针：***
函数完成后，它所占用的存储空间也随之释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。
只要一看是局部对象，而且返回的是该对象的指针和引用，那么就错了。
### 6.3.3 返回数组指针
## 6.4 函数重载
main()函数不能重载
## 6.5 特殊用途语言特性
我们一般将内联函数和constexpr函数放入到头文件内。
#### 内联函数可以避免函数调用的开销
内联函数会在每个调用点上内联的展开。
内联说明只是向编译器发出一个请求，编译器可以忽略这个请求。
#### constexpr函数
是指能用于常量表达式的函数。
### 6.5.3 调试帮助
#### assert预处理宏
```
assert(expr)
```
如果表达式为假，assert输出信息并终止程序的执行。如果表达式为真，assert什么也不做。
assert宏常用于检查“不能发生”的条件。
#### NDEBUG预处理变量
定义NDEBUG能够避免检查各种条件所需的运行时开销。也可以用此来编写自己的条件测试代码。

## 6.6 函数匹配
#### 确定候选函数和可行函数
函数匹配的第一步是选定本次调用对应的重载函数集，集合中的函数称为候选函数。
第二步考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数
第三部，寻找最佳匹配，实参类型与形参类型越接近，他们匹配的越好。
## 6.7 函数指针
函数指针指向的是函数，而非对象。
例如，有个函数长这样
```c++
bool lengthCompare(const string &, const string &)
```
那么，声明的函数指针长这样
```c++
bool (*pf)(const string &, const string &)//未初始化
```
其中两端的括号不能少。少了就变味了。
#### 使用函数指针
```c++
pf = lengthCompare；
pf = &lengthCompare； // 取地址符是可选的
```
我们还能直接使用指向函数的指针调用该函数，无须提前解引用指针
```c++
bool b1 = pf()；
bool b2 = (*pf)();
bool b3 = lengthCompare();
```
#### 函数指针形参
声明形式
```c++
// 第三个形参是函数类型，它会自动地转换成指向函数的指针
void useBigger(const string &s1, const string &s2,
                bool pf(const string &, const string &))；

// 等价的声明：显示的将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2,
                bool (*pf)(const string &, const string &))；
                
```

#### 返回指向函数的指针
和数组一样，懒得看了，希望以后遇到这类问题再看吧+——+