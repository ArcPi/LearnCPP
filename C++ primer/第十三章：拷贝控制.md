当定义一个类时，我们显式的或隐示的指定在此类型的对象那个的拷贝、移动、赋值和销毁时做什么。
一个类通过定义五中特殊的成员函数来控制这些操作：
拷贝构造函数
拷贝赋值运算符
移动构造函数
移动赋值运算符
析构函数
拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。
拷贝和移动赋值运算符定义了讲一个对象赋予同类型的另一个对象时做什么。
析构函数定义了当此类型对象销毁时做什么。
我们称这些操作为拷贝控制操作。
## 13.1 拷贝、赋值与销毁
### 13.1.1 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用，且额外参数有默认值，则此构造函数是拷贝构造函数。
例如
```
class Foo{
public：
        Foo(); // 默认构造函数
        Foo(const Foo&);  // 拷贝构造函数
}
```
拷贝构造函数的第一个参数必须是一个引用类型，而且最好是const引用。
#### 合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，及时我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。
对于某些类来说，合成构造函数用来组织我们拷贝该类类型的对象。而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中一次将每个非static成员拷贝到正在创建的对象中。
每个成员的类型决定了它如何拷贝：对类类型成员，会使用器拷贝函数来拷贝；内置类型的成员则直接拷贝。
#### 拷贝初始化
```
string dots(10, '.'); // 直接初始化
string s(dots); // 直接初始化
string s2 = dots； // 拷贝初始化
string null_books = "99-9999999-99"； // 拷贝初始化
string nines = string(100, '9');  // 拷贝初始化
```
当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。
当使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝带正在创建的对象中，如果有需要的话，还要进行类型转换。
拷贝舒适化通常使用拷贝构造函数来完成。如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。
拷贝初始化不仅在用=定义变量时会发生，在下列情况也会发生：
1. 将一个对象作为实参传递给一个非引用类型的形参。
2. 从一个返回类型为非引用类型的函数返回一个对象
3. 用花括号列表初始化一个数组中的元素或这一个聚合类中的成员

某些类类型还会对他们所分配的对象那个使用拷贝初始化。例如，我们初始化标准库容器或者是调用其insert或者push成员，容器会对其元素进行拷贝初始化。与之相对的，用emplace成员创建的元素都进行直接初始化。
#### 参数和返回值
在函数调用过程中，具有非引用类型的参数要进行拷贝初始化。类似地，当一个函数具有非引用的返回类型是，返回值会被用来初始化调用方的结果。
拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远不会成功。
#### 拷贝初始化的限制
#### 编译器可以绕过拷贝构造函数
### 13.1.2 拷贝赋值运算符
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为他合成一个。
#### 重载赋值运算符
重载运算符本质上是函数，operator关键字后接表示要定义的运算符的符号组成。例如operator=。
赋值运算符通常应该返回一个指向其左侧运算对象的引用。
#### 合成拷贝运算符
如果没有定义，编译器会为他生成一个合成拷贝赋值运算符。
对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。
合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。
### 13.1.3 析构函数
析构函数释放对象使用的资源，并销毁对象的非static数据成员。
析构函数是类的一个成员函数，名字由波浪号接类名构成。没有返回值，也不接受参数。
#### 析构函数完成什么工作
#### 什么时候会调用析构函数
无论何时一个对象被销毁，就会自动调用其析构函数：
1. 变量离开其作用域时被销毁
2. 当一个对象被销毁时，其成员被销毁
3. 容器（无论标准库容器还是数组）被销毁时，其元素被销毁
4. 对于动态分配的对象，当指向它的指针被销毁时
5. 对于临时对象，当穿件它的完整表达式结束时被销毁
#### 合成析构函数
对于某些类，合成析构函数被用来阻止该类型的对象被销毁。
### 13.1.4 三/五法则
三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。
新标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。
#### 需要析构函数的类也需要拷贝和赋值操作
如果一个类需要一个析构函数，我们几乎肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。
#### 需要拷贝操作的类也需要赋值操作，反之亦然
### 13.1.5 使用=default
我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本
当我们在类内用=default修饰成员的声明时，合成的函数将隐示的声明为内联的。
我们只能对具有合成版本的成员函数使用=default
### 13.1.6 阻止拷贝
对于某些类来说，拷贝构造函数和拷贝赋值运算符，这些操作没有意义，在此情况下，定义类时必须采用某种机制阻止拷贝或者赋值。例如，iostream类阻止了拷贝。
#### 定义删除的函数
我们可以将拷贝构造函数和拷贝赋值运算函数定义为删除的函数来阻止拷贝。
删除函数：我们虽然声明了它，但不能以任何方式使用他们
在函数参数列表后边加上=delete来指出我们希望将他定义为删除的
与=default不同，=delete必须出现在函数第一次声明的时候。
#### 析构函数不能是删除的成员
#### 合成的拷贝控制成员可能是删除的
对于某些类来说，编译器会将这些合成的成员定义为删除的函数：
1. 如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数被定义为删除的
2. 如果类的某个成员的拷贝搞糟函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。
3. 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝运算符被定义为删除的。
4. 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用城公园，它没有类内初始化其，或是类有一个const成员，它没有类内初始化其且其类型未显示定义默认构造函数，则该类的默认构造函数被定因为删除的。
综上，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。
#### private拷贝控制
## 13.2 拷贝控制和资源管理
### 13.2.1 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。
#### 类值拷贝赋值运算符
赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。如果可能，我们编写的赋值运算符还应该是异常安全的——当异常发生时能将左侧运算状态置于一个有意义的状态。
***关键概念***
1. 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
2. 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。
当编写一个赋值运算符时，一个好的模式是现将右侧运算对象那个拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源背熊安徽，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。
### 13.2.2 定义行为像指针的类
对于行为类似指针的类，我们需要为期定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是指向它分配的string。
#### 引用计数
1. 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象与正在创建的对象的共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为1.
2. 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数其，指出给定对象的状态又被一个新用户共享。
3. 析构函数递减计数器。如果计数器变味0，则析构函数释放状态。
4. 拷贝赋值运算符递增右侧运算对象的计数其，点左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味这它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。
#### 定义一个使用引用计数的类
## 13.3 交换操作
#### 编写我们自己的swap函数
#### 在赋值运算符中使用swap
使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。
## 13.4 拷贝控制示例
## 13.5 动态内存管理类
## 13.6 对象移动
[什么是左值 右值 右值引用](https://blog.csdn.net/hyman_yx/article/details/52044632)
为了支持移动操作，新标准引入了一种新的引用类型--右值引用。所谓右值引用就是必须绑定到右值的引用。我们通过&&来获得右值引用。
右值引用有一个重要的性质--只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动到”另一个对象中。
#### 左值持久；右值短暂
左值有持久的状态，右值要么是字面常量，要么是在表达式求职过程中创建的临时对象。
右值引用指向将要被销毁的对象。因此，我们可以帮定到右值引用的对象“窃取”状态。
#### 变量是左值
我们不能将一个右值引用绑定到一个右值引用类型的变量上。
#### 标准库move函数
我们可以显示地将一个左值转换为对应的右值引用类型。我们可以通过调用一个名为move的新标准可函数来获得绑定到左值上的右值引用。
move调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。
### 13.6.2 移动构造函数和移动赋值语句
不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
#### 移后源对象必须可析构
#### 合成的移动操作
只有一个类没有定义任何自己版本的拷贝控制成员，且类的每个非statci数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。
#### 移动右值，拷贝左值
#### 拷贝并交换赋值运算符和移动操作