面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OPP能处理在程序运行之前都未知的情况；泛型编程，在编译时就能获知类型了。
## 16.1 定义模板
### 16.1.1 模板函数
形式如下：
```c++
template <typename T>
int compare(const T &v1, const T &v2)
{
    returen v1 > v2;
}
```
模板定义以关键字template开始，后跟一个模板参数列表。
在模板定义中，模板参数列表不能为空。
#### 实例化函数模板
编译器用推断出的模板参数来为我们实例化一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参替代对应的模板参数来创建出模板的一个新“实例”。
#### 模板类型参数
#### 非类型模板参数
非类型模板参数的模板实参必须是常量表达式。
#### inline和constexpr的函数模板
函数模板可以声明为inline或者constexor的。
#### 编写类型无关的代码
编写泛型代码的两个重要原则：
1. 模板总的函数参数是const的引用。
2. 函数提中的条件判断仅使用<比较运算。

***模板程序应该尽量减少对实参类型的要求***
#### 模板编译
当编译器遇到一个模板定义是，它并不生成代码。只有当我们实例化出模板的一个特定版本是，班一起才会生成代码。
与非模板代码不同，模板的头文件同城既包括声明也包括定义。
***函数模板和类模板成员函数的定义通常放在头文件中***
#### 大多数编译错误在实例化期间报告
保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用这的责任。
### 16.1.2 类模板
类模板是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断参数类型。
为了使用类模板，我们必须在模板名后的尖括号中提供额外信息，用来代替模板参数的模板实参列表。
#### 定义类模板
#### 实例化类模板
#### 在模板作用域中引用模板类型
#### 类模板和友元
当一个类模板包含一个费模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元实例，也可以授权给特定实例。
### 16.1.3 模板参数
#### 模板参数与作用域
#### 模板声明
#### 使用类的类型成员
当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。
#### 默认模板实参
我们可以为函数和类模板提供默认模板实参。
#### 模板默认实参与类模板
### 16.1.4 成员模板
一个类可以包含本神是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。
#### 普通（非模板）类的成员模板
#### 类模板的成员模板
#### 实例化与成员模板
### 16.1.5 控制实例化
当模板被使用时才会进行实例化。这一特性以为着，相同的实例肯能出现在多个对象文件中。当两个或多个独立变异的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件都会有该模板的一个实例。
在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。可以通过显式实例化来避免这种开销。
显式实例化形式：
```c++
extern template declaration; // 实例化声明
template declaration； // 实例化定义
```
#### 实例化定义会实例化所有成员
与处理类模板的普通实例化不同，编译器会实例化该类所有成员。
### 16.1.6 效率与灵活性
## 16.2 模板实参推断
### 16.2.1 类型转换与模板类型参数
与往常一样，顶层const无论实在形参中韩式实参中，都会被忽略。在其他类型转换中，能在调用中应用于模板函数的包括如下两项：
1. const转换：可以将一个非const对象的引用（或指针）传递给一个const的引用（或指针）形参。
2. 数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。

#### 使用相同模板参数类型的函数形参
### 16.2.2 函数模板显式实参
### 16.2.3 尾置返回类型与类型转换
#### 进行类型转换的标准库模板
### 16.2.4 函数指针和实参推断
### 16.2.5 模板实参推断和引用
编译器会应用正常的引用绑定规则：
const是底层的，不是顶层的
#### 从左值引用函数参数推断类型
若是这样的
```c++
template <typename T> void f1(T&); // 实参必须是个左值
```
```c++
f1(5)； // 这种是错误的，传递的实参必须是一个左值
```
若是这样的
```c++
template <typename T> void f1(const T&); // 可以接受一个右值
```
```c++
f1(5)； // 这种是正确的
```
#### 引用折叠和右值引用参数
如果一个函数参数是指向模板参数类型的右值引用（如，T&&），则可以传递给他任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（T&）。
#### 编写接受右值引用参数的模板函数
在实际中，右值引用通常用于两种情况：模板转发其实参或模板被重载。
### 16.2.6 理解std::move
#### std::move是如何定义的
在标准库中是这样定义move的
```c++
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
    return static_cast<typename remove_reference<T>::type&&>(t);
}
```
首先，move的函数参数T&&是一个指向模板参数类型参数的右值引用。通过引用折叠，此参数可以与任何类型的实参匹配。特别是，我们既可以传递给move一个左值，也可以传递给它一个右值：
```c++
string s1("hi"), s2;
s2 = std::move(string("bye!")); // 正确：从一个右值移动数据
s2 = std::move(s1); // 正确：但赋值之后，s1的值是不确定的
```
#### std::move是如何工作的
在第一个赋值中，传递给move的实参是string的构造函数的右值结果--string("bye!")。如前边我们见到过的，当一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型。因此，在std::move（string（“bye！”））中：
1. 推断出的T的类型为string。
2. 因此，remove_reference用string进行实例化。
3. remove_reference<string>的type成员是string。
4. move的函数参数t的类型为string&& 。
5. move的函数参数t的类型为string&& 。

因此，这个调用实例化move<string>， 即函数
```
string&& move(string &&t)
```
函数提返回static_cast<string&&>(t)。t的类型已经是string&&，于是类型转换什么都不做。因此调用的结果就是它所接受的右值引用。
现在考虑第二个赋值，他调用了std::move（）。在此调用中，传递给move的实参是一个左值。这样：
1. 推断出的T的类型为string&
2. 因此，remove_reference用string&进行实例化。
3. remove_reference<string>的type成员是string。
4. move的返回类型仍是string&&。
5. move的函数参数t实例化为string& &&，会折叠为string&。
#### 从一个左值static_cast到一个右值引用是允许的
我们可以用static_cast显式的将一个左值转换为一个右值引用。
### 16.2.7 转发
某些函数需要将其一个或多个参数连同类型不变的转发给其他函数。再次情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是是const的以及实参是左值还是右值。
