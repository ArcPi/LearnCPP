面向对象编程和泛型编程都能处理在编写程序时不知道类型的情况。不同之处在于：OPP能处理在程序运行之前都未知的情况；泛型编程，在编译时就能获知类型了。
## 16.1 定义模板
### 16.1.1 模板函数
形式如下：
```c++
template <typename T>
int compare(const T &v1, const T &v2)
{
    returen v1 > v2;
}
```
模板定义以关键字template开始，后跟一个模板参数列表。
在模板定义中，模板参数列表不能为空。
#### 实例化函数模板
编译器用推断出的模板参数来为我们实例化一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参替代对应的模板参数来创建出模板的一个新“实例”。
#### 模板类型参数
#### 非类型模板参数
非类型模板参数的模板实参必须是常量表达式。
#### inline和constexpr的函数模板
函数模板可以声明为inline或者constexor的。
#### 编写类型无关的代码
编写泛型代码的两个重要原则：
1. 模板总的函数参数是const的引用。
2. 函数提中的条件判断仅使用<比较运算。

***模板程序应该尽量减少对实参类型的要求***
#### 模板编译
当编译器遇到一个模板定义是，它并不生成代码。只有当我们实例化出模板的一个特定版本是，班一起才会生成代码。
与非模板代码不同，模板的头文件同城既包括声明也包括定义。
***函数模板和类模板成员函数的定义通常放在头文件中***
#### 大多数编译错误在实例化期间报告
保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用这的责任。
### 16.1.2 类模板
类模板是用来生成类的蓝图的。与函数模板的不同之处是，编译器不能为类模板推断参数类型。
为了使用类模板，我们必须在模板名后的尖括号中提供额外信息，用来代替模板参数的模板实参列表。
#### 定义类模板
#### 实例化类模板
#### 在模板作用域中引用模板类型
#### 类模板和友元
当一个类模板包含一个费模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元实例，也可以授权给特定实例。
### 16.1.3 模板参数
#### 模板参数与作用域
#### 模板声明
#### 使用类的类型成员
当我们希望通知编译器一个名字表示类型时，必须使用关键字typename，而不能使用class。
#### 默认模板实参
我们可以为函数和类模板提供默认模板实参。
#### 模板默认实参与类模板
### 16.1.4 成员模板
一个类可以包含本神是模板的成员函数。这种成员被称为成员模板。成员模板不能是虚函数。
#### 普通（非模板）类的成员模板
#### 类模板的成员模板
#### 实例化与成员模板
### 16.1.5 控制实例化
当模板被使用时才会进行实例化。这一特性以为着，相同的实例肯能出现在多个对象文件中。当两个或多个独立变异的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件都会有该模板的一个实例。
在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。可以通过显式实例化来避免这种开销。
显式实例化形式：
```c++
extern template declaration; // 实例化声明
template declaration； // 实例化定义
```
#### 实例化定义会实例化所有成员
与处理类模板的普通实例化不同，编译器会实例化该类所有成员。
### 16.1.6 效率与灵活性
## 16.2 模板实参推断
### 16.2.1 类型转换与模板类型参数